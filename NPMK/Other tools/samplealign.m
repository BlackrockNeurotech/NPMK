function [structout1,structout2,varargout] = samplealign(structin1,structin2,varargin)
%UNTITLED Summary of this function goes here
%   Detailed explanation goes here

% Basic input/output health checking
narginchk(2,inf);

Data = {structin1, structin2};

if nargin >= 3
    for n = 3:nargin   
        Data{n} = varargin{n-2};
    end
end

if nargin ~= nargout
    error('There must be the same number of input and output arguments.')
end

% Generate structures for each field that is affected by this function;
ts_PTP = cell(length(Data),1);
ts_sums = zeros(length(Data),1);
samplingrates = cell(length(Data),1);
timeres = zeros(length(Data),1);
freq = zeros(length(Data),1);
datalengths = cell(length(Data),1);
durations = cell(length(Data),1);
segmentinds = cell(length(Data),1);
segmenteddata = cell(length(Data),1);
segmentedts = cell(length(Data),1);
segmenteddatapoints = cell(length(Data),1);

% High level input data checking.
for i=1:length(Data)
    fnames{i} = Data{i}.MetaTags.Filename;
    % Make sure the structures are correct
    if ~isfield(Data{i},'MetaTags') && ~isfield(Data{i},'Data') && ~isfield(Data{i},'RawData') && ~isfield(Data{i},'ElectrodesInfo')
        error('All input arguments must be data structs generated by openNSx.')
    elseif Data{i}.MetaTags.TimeRes ~= 1e9 && ~strcmp(Data{i}.MetaTags.FileSpec,'3.0') && length(Data{i}.MetaTags.DataPoints) ~= sum(Data{i}.MetaTags.DataPoints)
        error('Struct input arguments generated by openNSx must have nanosecond resolution and have been generated by Central v7.6.0')
    end
    
    % Generate the PTP timestamp vectors, which will be acted upon by this
    % function
    ts_PTP{i} = Data{i}.MetaTags.Timestamp;

    % Identifying average gap between data points
    ts_diffs{i} = diff(double(Data{i}.MetaTags.Timestamp));

    % Extract the claimed resolution and sampling frequency of each
    % recording
    timeres(i) = double(Data{i}.MetaTags.TimeRes);
    freq(i) = double(Data{i}.MetaTags.SamplingFreq);

    % Clock drift patch kills ability to segment files. This check will
    % allow segments to be reintroduced into the data structures if a
    % timestamp difference of 110% greater than expected is identified
    segmentinds{i} = find([ts_diffs{i}(1) ts_diffs{i}] > (timeres(i)/freq(i) + timeres(i)/freq(i)/10));
    segmenteddata{i} = cell(length(segmentinds{i})+1,1);
    segmentedts{i} = cell(length(segmentinds{i})+1,1);
    if ~isempty(segmentinds{i})
        for ii = 1:length(segmentinds{i})+1
            if ii == 1
                inds = 1:segmentinds{i}(ii)-1;
            elseif ii <= length(segmentinds{i})
                inds = segmentinds{i}(ii-1):segmentinds{i}(ii)-1;
            else
                inds = segmentinds{i}(ii-1):length(Data{i}.Data);
            end
            segmenteddata{i}{ii} = Data{i}.Data(:,inds);
            segmentedts{i}{ii} = Data{i}.MetaTags.Timestamp(:,inds);
            datalengths{i}(ii) = length(inds);
            durations{i}(ii) = segmentedts{i}{ii}(end)- segmentedts{i}{ii}(1);

            % Calculate the ratio between time gaps and expected time gap 
            % based on the sampling rate of the recording. A recording
            % where the claimed sampling rate and true sampling rate based
            % off PTP time will have a ratio of 1;
            samplingrates{i}(ii) = mean(diff(segmentedts{i}{ii})/(timeres(i)/freq(i)));
        end
    else
        segmenteddata{i} = Data{i}.Data;
        segmentedts{i} = Data{i}.MetaTags.Timestamp;
        datalengths{i} = length(Data{i}.Data);
        durations{i} = segmentedts{i}(end) - segmentedts{i}(1);
        samplingrates{i} = mean(ts_diffs{i})/(timeres(i)/freq(i));
    end

end

if length(fnames) ~= length(unique(fnames))
    error('Do not attempt to align data collected from the same Hub or NSP duirng the same recording. Clock drift only occurs between unique units.')
end


%% Perform drift correction
% Identify the file that has the densest recording, i.e. identify which
% file has the lowest sampling ratio. This file's data will not be
% affected by adding samples to it and will serve as the base for adding
% samples to the other structures.
msamplingrates = mean(cell2mat(samplingrates),2);
[~, s] = min(msamplingrates);

% Number of necessary added samples depends on the sampling rate.
% Normalization factor is here.
normfactor = zeros(length(Data),1);
tempdata = cell(length(Data),1);
tempts = cell(length(Data),1);
tempdatapoints = cell(length(Data),1);
basefreq = freq(s);


for j=1:length(Data)
    % Remove affected elements from the structure
    Data{j} = rmfield(Data{j},'Data');
    Data{j}.MetaTags = rmfield(Data{j}.MetaTags,{'Timestamp','DataPoints','DataDurationSec','DataPointsSec'});
    normfactor(j) = freq(j)/basefreq;
    startind = 1;
    if j~=s
        if length(samplingrates{j}) > 1
            for jj = 1:length(samplingrates{j})
                startind = 1;
                % Calculate the number of samples that should be added
                addedsamples = round(abs(1-samplingrates{j}(jj))*datalengths{j}(jj)*normfactor(j)-abs(1-samplingrates{s}(jj))*datalengths{s}(jj)*normfactor(s));
                
                % It is possible that the above caluclation can be off if the
                % recording started on one file several samples before or after the
                % base file. This corrects for the start time mismatches.
                
                if durations{j}(jj) > durations{s}(jj) % If the total time is > to base
                    % Remove some samples
                    addedsamples = round((addedsamples/normfactor(j) - abs((durations{j}(jj) - durations{s}(jj)) / (timeres(j)/freq(j)))));
        
                elseif durations{j}(jj) < durations{s}(jj) % else if its < than base
                    % Add some samples
                    addedsamples = round((addedsamples/normfactor(j) + abs((durations{j}(jj) - durations{s}(jj)) / (timeres(j)/freq(j)))));
                end
        
                % Establish where the extra points should be added
                gap = round(datalengths{j}(jj)/(abs(addedsamples)+1));
        
                % Repeat values in the struct. Simply repeat the data frame on the
                % indices identified above.
                tempts{j}{jj} = segmentedts{j}{jj}(1);
                tempdata{j}{jj} = [];
                while startind < datalengths{j}(jj)
                    % Error correction for overflow beyond the .Data length
                    if startind+gap < datalengths{j}(jj)
                        tempdata{j}{jj} = [tempdata{j}{jj} segmenteddata{j}{jj}(:,startind:(startind+gap))];
                    else
                        tempdata{j}{jj} = [tempdata{j}{jj} segmenteddata{j}{jj}(:,startind:end)];
                    end
                    startind = startind + gap;
                end
            end
        else
            % Calculate the number of samples that should be added
            addedsamples = round(abs(1-samplingrates{j})*datalengths{j}*normfactor(j)-abs(1-samplingrates{s})*datalengths{s}*normfactor(s));
            
            % It is possible that the above caluclation can be off if the
            % recording started on one file several samples before or after the
            % base file. This corrects for the start time mismatches.
            
            if durations{j} > durations{s} % If the total time is > to base
                % Remove some samples
                addedsamples = round((addedsamples/normfactor(j) - abs((durations{j} - durations{s}) / (timeres(j)/freq(j)))));
    
            elseif durations{j} < durations{s} % else if its < than base
                % Add some samples
                addedsamples = round((addedsamples/normfactor(j) + abs((durations{j} - durations{s}) / (timeres(j)/freq(j)))));
            end
    
            % Establish where the extra points should be added
            gap = round(datalengths{j}/(abs(addedsamples+1)));
    
            % Repeat values in the struct. Simply repeat the data frame on the
            % indices identified above.
            tempts{j} = segmentedts{j}(1); 
            tempdata{j} = [];
            tempdatapoints{j} = [];
            while startind < datalengths{j}
                % Error correction for overflow beyond the .Data length
                if startind+gap < datalengths{j}
                    tempdata{j} = [tempdata{j} segmenteddata{j}(:,startind:(startind+gap))];
                else
                    tempdata{j} = [tempdata{j} segmenteddata{j}(:,startind:end)];
                end
                startind = startind + gap;
            end
        end
    else
        if length(samplingrates{j}) > 1
            for jj = 1:length(samplingrates)
                tempts{j}{jj} = segmentedts{j}{jj}(1);
                tempdata{j}{jj} = segmenteddata{j}{jj};
            end
        else
            tempts{j} = segmentedts{j}(1);
            tempdata{j} = segmenteddata{j};
        end
    end
    Data{j}.Data = tempdata{j};
    if iscell(tempts{j})
        for jj = 1:length(tempts{j})
            Data{j}.MetaTags.Timestamp(jj) = tempts{j}{jj}(1);
            Data{j}.MetaTags.DataPoints(jj) = length(Data{j}.Data{jj});
            Data{j}.MetaTags.DataDurationSec(jj) = floor(length(Data{j}.Data{jj})/freq(j));
            Data{j}.MetaTags.DataPointsSec(jj) = floor(length(Data{j}.Data{jj})/freq(j));
        end
    else
        Data{j}.MetaTags.Timestamp = tempts{j}(1);
        Data{j}.MetaTags.DataPoints = length(Data{j}.Data);
        Data{j}.MetaTags.DataDurationSec = floor(length(Data{j}.Data)/freq(j));
        Data{j}.MetaTags.DataPointsSec = floor(length(Data{j}.Data)/freq(j));
    end
    
    
end

structout1 = Data{1};
structout2 = Data{2};
if nargout == 3
    varargout{1} = Data{3};
end

