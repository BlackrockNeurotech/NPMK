function [structout1,structout2,varargout] = samplealign(structin1,structin2,varargin)
%UNTITLED Summary of this function goes here
%   Detailed explanation goes here

% Basic input/output health checking
narginchk(2,inf);

Data = {structin1, structin2};

if nargin >= 3
    for n = 3:nargin   
        Data{n} = varargin{n-2};
    end
end

if nargin ~= nargout
    error('There must be the same number of input and output arguments.')
end

% Generate structures for each field that is affected by this function;
ts_PTP = cell(length(Data),1);
ts_sums = zeros(length(Data),1);
samplingrates = zeros(length(Data),1);
timeres = zeros(length(Data),1);
freq = zeros(length(Data),1);
datalengths = zeros(length(Data),1);
segmentinds = cell(length(Data),1);


issegmented = false;

% High level input data checking.
for i=1:length(Data)
    fnames{i} = Data{i}.MetaTags.Filename;
    % Make sure the structures are correct
    if ~isfield(Data{i},'MetaTags') && ~isfield(Data{i},'Data') && ~isfield(Data{i},'RawData') && ~isfield(Data{i},'ElectrodesInfo')
        error('All input arguments must be data structs generated by openNSx.')
    elseif Data{i}.MetaTags.TimeRes ~= 1e9 && ~strcmp(Data{i}.MetaTags.FileSpec,'3.0') && length(Data{i}.MetaTags.DataPoints) ~= sum(Data{i}.MetaTags.DataPoints)
        error('Struct input arguments generated by openNSx must have nanosecond resolution and have been generated by Central v7.6.0')
    end
    
    % Generate the PTP timestamp vectors, which will be acted upon by this
    % function
    ts_PTP{i} = Data{i}.MetaTags.Timestamp;

    % Identifying average gap between data points
    ts_diffs{i} = diff(double(Data{i}.MetaTags.Timestamp));

    % Calculate the total PTP time, number of samples, resolutionn, and
    % sampling frequency of each recording
    ts_sums(i) = sum(ts_diffs{i});
    datalengths(i) = length(Data{i}.Data);
    timeres(i) = double(Data{i}.MetaTags.TimeRes);
    freq(i) = double(Data{i}.MetaTags.SamplingFreq);

    % Calculate the ratio between time gaps and expected time gap based on
    % the sampling rate of the recording. A recording where the claimed
    % sampling rate and true sampling rate based off PTP time will have a
    % ratio of 1;
    samplingrates(i) = mean(ts_diffs{i}/(timeres(i)/freq(i)));
end

if length(fnames) ~= length(unique(fnames))
    error('Do not attempt to align data collected from the same Hub or NSP duirng the same recording. Clock drift only occurs between unique units.')
end


%% Perform drift correction
% identify the file that has the densest recording, i.e. identify which
% file has the lowest sampling ratio. This file's data will not be
% affected by adding samples to it and will serve as the base for adding
% samples to the other structures.
[~, s] = min(samplingrates);

% Number of necessary added samples depends on the sampling rate.
% Normalization factor is here.
normfactor = zeros(length(Data),1);
indgap = cell(length(Data),1);
basefreq = freq(s);
for j=1:length(Data)
    normfactor(j) = freq(j)/basefreq;
    if j~=s
        % Calculate the number of samples that should be added
        addedsamples = floor(abs(1-samplingrates(j))*datalengths(j)*normfactor(j)-abs(1-samplingrates(s))*datalengths(s)*normfactor(s));
        
        % It is possible that the above caluclation can be off if the
        % recording started on one file several samples before or after the
        % base file. This corrects for the start time mismatches.
        
        if ts_sums(j) > ts_sums(s) % If the total time is > to base
            % Remove some samples
            addedsamples = floor((addedsamples/normfactor(j) - abs((ts_sums(j) - ts_sums(s)) / (timeres(j)/freq(j)))));

        elseif ts_sums(j) < ts_sums(s) % else if its < than base
            % Add some samples
            addedsamples = floor((addedsamples/normfactor(j) + abs((ts_sums(j) - ts_sums(s)) / (timeres(j)/freq(j)))));
        end

        % Establish where the extra points should be added
        gap = floor(datalengths(j)/(abs(addedsamples)));

        % Repeat values in the struct. Simply repeat the data frame on the
        % indices identified above.
        tempdata = [];
        tempts = [];
        startind = 1;
        indgap{j} = [];
        while startind < datalengths(j)
            % Error correction for overflow beyond the .Data length
            if startind+gap < datalengths(j)
                tempts = [tempts ts_PTP{j}(startind:startind+gap)];
                tempdata = [tempdata Data{j}.Data(:,startind:(startind+gap))];
            else
                tempts = [tempts ts_PTP{j}(startind:end)];
                tempdata = [tempdata Data{j}.Data(:,startind:end)];
            end
            indgap{j} = [indgap{j} length(tempdata)];
            startind = startind + gap;
        end
    else
        tempts = Data{j}.MetaTags.Timestamp;
        tempdata = Data{j}.Data;
    end

    ts_diffs_post = diff(tempts);

    % Clock drift patch kills ability to segment files. This check will
    % allow segments to be reintroduced into the data structures if a
    % timestamp difference of 110% greater than expected is identified
    segmentinds{j} = find(ts_diffs_post > timeres(j)/freq(j) + timeres(j)/freq(j)/10);
    
    % Correct for corner case where the added sample is directly on top
    % of the same index where a segment needs to occur.
    while sum(ismember(segmentinds{j},indgap{j})) > 0
        for seg = 1:length(segmentinds{j})
            if sum(cell2mat(indgap{j}) == segmentinds{j}(seg)) > 0
                segmentinds{j}(seg) = segmentinds{j}(seg) + 1;
            end
        end
    end

    % Remove affected elements from the structure and replace it with the
    % proper temporary elements.
    Data{j} = rmfield(Data{j},'Data');
    Data{j}.MetaTags = rmfield(Data{j}.MetaTags,{'Timestamp','DataPoints','DataDurationSec','DataPointsSec'});

    if ~isempty(segmentinds{j})
        Data{j}.MetaTags.Timestamp = [tempts(1), tempts(segmentinds{j})];
        Data{j}.MetaTags.DataPoints = [segmentinds{j} length(tempdata)-segmentinds{j}(end)];
        Data{j}.MetaTags.DataDurationSec = floor(Data{j}.MetaTags.DataPoints/freq(j));
        Data{j}.MetaTags.DataPointsSec = floor(Data{j}.MetaTags.DataPoints/freq(j));
        segmenttemp = cell(1,length(segmentinds{j})+1);
        for jj=1:length(segmentinds{j})
            if jj==1
                segmenttemp{jj} = tempdata(:,1:segmentinds{j}(jj));
            elseif jj<length(segmentinds{j})
                segmenttemp{jj} = tempdata(:,segmentinds{j}(jj):segmentinds{j}(jj+1));
            else
                segmenttemp{jj} = tempdata(:,segmentinds{j}(jj):end);
            end
            Data{j}.Data{jj} = segmenttemp{jj};
        end
    else
        Data{j}.Data = tempdata;
        Data{j}.MetaTags.Timestamp = [tempts(1)];
        Data{j}.MetaTags.DataPoints = length(tempdata);
        Data{j}.MetaTags.DataDurationSec = floor(length(tempdata)/freq(j));
        Data{j}.MetaTags.DataPointsSec = floor(length(tempdata)/freq(j));
    end

end

structout1 = Data{1};
structout2 = Data{2};
if nargout == 3
    varargout{1} = Data{3};
end

